≡ Краткое руководство Markdown

## Решение задач из темы 7.
### Вариант 1
Напишите программу, которая на вход будет принимать список списков ([[0, 4, 8], [‘a’, -0], [1, 5]]) и определять первый валидный подмассив (он гарантированно есть). Валидным считается массив, состоящий из двух натуральных чисел, при чем первое число должно быть меньше второго. Назовем эти числа А и В. Далее программа генерирует случайное натуральное число N, которое лежит в диапазоне [А, В] и генерирует две лесенки из символа «*», где количество символов в первой лестнице варьируется от B до N, а во второй от A до N.
Программа должна состоять из трех функций: check_input, get_ladder и main.
Функция check_input принимает на вход массив, проверяет его валидность. Если данные корректны – возвращает значение True, иначе False.
Функция get_ladder принимает на вход валидный массив, генерирует число N и массив данных для вывода лестницы.
Функция main принимает на вход список списков, находит первый валидный подмассив, передает значения подмассива на функцию get_ladder и печатает результат.


### Вариант 2
Напишите программу, которая на вход будет принимать список, элементы которого могут быть любыми. В данном массиве необходимо найти самую длинную строку, если таких будет несколько, то выбрать нужно первую. В найденной строке необходимо найти самую длинную подстроку без повторений. Таких строк может быть несколько, но возвращать функция должна первую подстроку. Результатом функции должно быть два объекта: индекс самой длинной строки списка и самая длинная подстрока без повторений. Если в исходном списке нет строк, то программа должна вернуть индекс -1 и пустую строку.
Программа должна состоять из трех функций: check_input, get_substring и main.
Функция check_input проверяет элемент массива и возвращает True, если элемент – строка, иначе – False.
Функция get_substring находит самую длинную подстроку без повторений в переданной строке.
Функция main принимает на вход список, находит самую длинную строку списка, полученную строку передает на метод get_substring и печатает индекс самой длинной строки в массиве и найденную подстроку.


### Вариант 3
Напишите программу, которая на вход принимает список списков ([['11', 8], ['14.02', -9], [], [5, '11.03'], ['11.03', 5]]) и определять первый валидный подмассив (он гарантированно есть). Валидным считается подмассив состоящих из двух элементов: первый – строка в формате %H.%M (часы и минуты), второй – натуральное число N. Далее программа увеличивает полученное валидное время на N часов и N минут. В результате программа должна вернуть полученное новое время в формате %H.%M.
Программа должна состоять из трех функций: check_input, calculate_time и main.
Функция check_input принимает на вход массив, проверяет его валидность. Если данные корректны – возвращает значение True, иначе False.
Функция calculate_time принимает на вход валидный массив, извлекает время и число N, добавляет N часов и N минут ко времени и возвращает полученный результат в формате %H.%M.
Функция main принимает на вход список списков, находит первый валидный элемент, передает его на функцию calculate_time и печатает результат.


### Вариант 4
Напишите программу, которая на вход будет принимать список ([’11-06-15’, ‘2001.40.40’ ‘2023.06.22’, 5, ‘string’]) и определять первый валидный элемент (он гарантированно есть). Элементы списка могут быть любыми. Валидным элементов считается строка в формате %Y.%m.%d (год.месяц.день). Далее программа считает количество понедельников между текущей датой и датой из списка (включая обе даты). Результатом программы должно быть число.
Программа должна состоять из трех функций: check_input, count_mondays и main.
Функция check_input проверяет элемент массива и возвращает True, если элемент – валидный, иначе – False.
Функция count_mondays принимает валидную дату и находит количество понедельников между полученной датой и текущей.
Функция main принимает на вход массив, находит первый валидный элемент, передает его на функцию count_mondays и печатает число.


